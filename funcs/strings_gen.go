// Code generated by gencel. DO NOT EDIT.

package funcs

import (
	"github.com/google/cel-go/cel"
	"github.com/google/cel-go/common/types"
	"github.com/google/cel-go/common/types/ref"
)

var stringsHumanDurationGen = cel.Function("HumanDuration",
	cel.Overload("HumanDuration_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x StringFuncs

			result, err := x.HumanDuration(args[0])
			if err != nil {
				return types.WrapErr(err)
			}
			return types.String(result)

		}),
	),
)

var stringsHumanDurationGen2 = cel.Function("humanDuration",
	cel.Overload("humanDuration_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x StringFuncs

			result, err := x.HumanDuration(args[0])
			if err != nil {
				return types.WrapErr(err)
			}
			return types.String(result)

		}),
	),
)



var stringsHumanSizeGen = cel.Function("HumanSize",
	cel.Overload("HumanSize_interface{}",
		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x StringFuncs

			result, err := x.HumanSize(args[0].Value())
			if err != nil {
				return types.WrapErr(err)
			}
			return types.String(result)

		}),
	),
)

var stringsHumanSizeGen2 = cel.Function("humanSize",
	cel.Overload("humanSize_interface{}",
		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x StringFuncs

			result, err := x.HumanSize(args[0].Value())
			if err != nil {
				return types.WrapErr(err)
			}
			return types.String(result)

		}),
	),
)

var stringsSemverGen = cel.Function("Semver",
	cel.Overload("Semver_string",

		[]*cel.Type{
			cel.StringType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x StringFuncs

			result, err := x.SemverMap(args[0].Value().(string))
			if err != nil {
				return types.WrapErr(err)
			}
			return types.DefaultTypeAdapter.NativeToValue(result)
		}),
	),
)

var stringsSemverCompareGen = cel.Function("SemverCompare",
	cel.Overload("SemverCompare_string_string",

		[]*cel.Type{
			cel.StringType, cel.StringType,
		},
		cel.BoolType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x StringFuncs

			result, err := x.SemverCompare(args[0].Value().(string), args[1].Value().(string))
			if err != nil {
				return types.WrapErr(err)
			}
			return types.Bool(result)
		}),
	),
)

var stringsAbbrevGen = cel.Function("Abbrev",
	cel.Overload("Abbrev_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x StringFuncs
			list, err := sliceToNative[interface{}](args[0].(ref.Val))
			if err != nil {
				return types.WrapErr(err)
			}

			result, err := x.Abbrev(list...)
			if err != nil {
				return types.WrapErr(err)
			}
			return types.String(result)

		}),
	),
)

var stringsReplaceAllGen = cel.Function("replaceAll",
	cel.MemberOverload("ReplaceAll_string_string_interface{}",
		[]*cel.Type{
			cel.StringType, cel.StringType, cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {
			var x StringFuncs
			return types.String(x.ReplaceAll(args[0].Value().(string), args[1].Value().(string), args[2]))
		}),
	),
)

var stringsContainsGen = cel.Function("Contains",
	cel.Overload("Contains_string_interface{}",

		[]*cel.Type{
			cel.StringType, cel.DynType,
		},
		cel.BoolType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x StringFuncs

			return types.Bool(x.Contains(args[0].Value().(string), args[1]))

		}),
	),
)


var stringsRepeatGen = cel.Function("repeat",
	cel.MemberOverload("string_repeat",
		[]*cel.Type{
			cel.StringType,cel.IntType,
		},
		cel.StringType,
		cel.BinaryBinding(func(lhs, rhs ref.Val) ref.Val {
			var x StringFuncs
			result, err := x.Repeat(int(rhs.Value().(int64)), lhs.Value())
			if err != nil {
				return types.WrapErr(err)
			}
			return types.String(result)

		}),
	),
)

var stringsSortGen = cel.Function("Sort",
	cel.Overload("Sort_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {
			list, err := sliceToNative[interface{}](args[0].(ref.Val))
			if err != nil {
				return types.WrapErr(err)
			}

			var x StringFuncs
			result, err := x.Sort(list)
			if err != nil {
				return types.WrapErr(err)
			}

			return types.DefaultTypeAdapter.NativeToValue(result)
		}),
	),
)

var stringsSplitNGen = cel.Function("SplitN",
	cel.Overload("SplitN_string_int_interface{}",

		[]*cel.Type{
			cel.StringType, cel.IntType, cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x StringFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.SplitN(args[0].Value().(string), args[1].Value().(int), args[2]))

		}),
	),
)



var stringsTrimPrefixGen = cel.Function("trimPrefix",
	cel.MemberOverload("string_trimPrefix",

		[]*cel.Type{
			cel.StringType, cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x StringFuncs

			return types.String(x.TrimPrefix(args[0].Value().(string), args[1]))

		}),
	),
)

var stringsTrimSuffixGen = cel.Function("trimSuffix",
	cel.MemberOverload("string_trimSuffix",

		[]*cel.Type{
			cel.StringType, cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x StringFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.TrimSuffix(args[1].Value().(string), args[0]))

		}),
	),
)




var stringsTitleGen = cel.Function("title",
	cel.MemberOverload("string_title",
		[]*cel.Type{
			cel.StringType,
		},
		cel.StringType,
		cel.UnaryBinding(
			func(arg ref.Val) ref.Val {
			var x StringFuncs
			return types.String(x.Title(arg))
		}),
	),
)

var stringsToUpperGen = cel.Function("toUpper",
	cel.Overload("string_toUpper",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x StringFuncs

			return types.String(x.ToUpper(args[0]))

		}),
	),
)

var stringsToLowerGen = cel.Function("toLower",
	cel.Overload("string_toLower",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x StringFuncs

			return types.String(x.ToLower(args[0]))

		}),
	),
)

var stringsTrimSpaceGen = cel.Function("trimSpace",
	cel.Overload("string_trimSpace",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x StringFuncs

			return types.String(x.TrimSpace(args[0]))

		}),
	),
)

var stringsTruncGen = cel.Function("trunc",
	cel.MemberOverload("string_trunc",

		[]*cel.Type{
			cel.IntType, cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x StringFuncs

			return types.String(x.Trunc(args[0].Value().(int), args[1]))

		}),
	),
)

var stringsIndentGen = cel.Function("indent",
	cel.MemberOverload("string_indent",
		[]*cel.Type{
			cel.StringType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x StringFuncs
			list, err := sliceToNative[interface{}](args[0].(ref.Val))
			if err != nil {
				return types.WrapErr(err)
			}

			result, err := x.Indent(list...)
			if err != nil {
				return types.WrapErr(err)
			}
			return types.String(result)
		}),
	),
)

var stringsSlugGen = cel.Function("slug",
	cel.MemberOverload("string_slug",

		[]*cel.Type{
			cel.StringType,
		},
		cel.StringType,
		cel.UnaryBinding(func(arg ref.Val) ref.Val {

			var x StringFuncs

			return types.String(x.Slug(arg))

		}),
	),
)

var stringsQuoteGen = cel.Function("quote",
	cel.MemberOverload("string_quote",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.UnaryBinding(func(arg ref.Val) ref.Val {

			var x StringFuncs

			return types.String(x.Quote(arg))

		}),
	),
)

var stringsShellQuoteGen = cel.Function("shellQuote",
	cel.MemberOverload("string_shell_quote",

		[]*cel.Type{
			cel.StringType,
		},
		cel.StringType,
		cel.UnaryBinding(func(arg ref.Val) ref.Val {

			var x StringFuncs

			return types.String(x.ShellQuote(arg))

		}),
	),
)

var stringsSquoteGen = cel.Function("squote",
	cel.MemberOverload("string_squote",

		[]*cel.Type{
			cel.StringType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x StringFuncs

			return types.String(x.Squote(args[0]))

		}),
	),
)

var stringsSnakeCaseGen = cel.Function("snakeCase",
	cel.MemberOverload("string_snakeCase",

		[]*cel.Type{
			cel.StringType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x StringFuncs

			result, err := x.SnakeCase(args[0])
			if err != nil {
				return types.WrapErr(err)
			}
			return types.String(result)

		}),
	),
)

var stringsCamelCaseGen = cel.Function("camelCase",
	cel.MemberOverload("string_camel_case",

		[]*cel.Type{
			cel.StringType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x StringFuncs

			result, err := x.CamelCase(args[0])
			if err != nil {
				return types.WrapErr(err)
			}
			return types.String(result)

		}),
	),
)

var stringsKebabCaseGen = cel.Function("kebabCase",
	cel.MemberOverload("string_kebab_case",

		[]*cel.Type{
			cel.StringType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x StringFuncs

			result, err := x.KebabCase(args[0])
			if err != nil {
				return types.WrapErr(err)
			}
			return types.String(result)

		}),
	),
)

var stringsWordWrapGen = cel.Function("WordWrap",
	cel.Overload("WordWrap_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x StringFuncs
			list, err := sliceToNative[interface{}](args[0].(ref.Val))
			if err != nil {
				return types.WrapErr(err)
			}

			result, err := x.WordWrap(list...)
			if err != nil {
				return types.WrapErr(err)
			}
			return types.String(result)

		}),
	),
)

var stringsRuneCountGen = cel.Function("runeCount",
	cel.MemberOverload("string_rune_count",

		[]*cel.Type{
			cel.StringType,
		},
		cel.IntType,
		cel.UnaryBinding(func(arg ref.Val) ref.Val {

			var x StringFuncs

			result, err := x.RuneCount(arg.Value().(string))
			if err != nil {
				return types.WrapErr(err)
			}
			return types.Int(int64(result))

		}),
	),
)
