// Code generated by "gencel";
// DO NOT EDIT.

package funcs

import "github.com/google/cel-go/common/types"
import "github.com/google/cel-go/cel"
import "github.com/google/cel-go/common/types/ref"

var FindregexpGen = cel.Function("Find",
	cel.Overload("Find_interface{}_interface{}",

		[]*cel.Type{
			cel.DynType, cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			// Need to figure this out
			name := "Flanksource"
			return types.DefaultTypeAdapter.NativeToValue([]string{name, name + "suffix"})

		}),
	),
)

var FindAllregexpGen = cel.Function("FindAll",
	cel.Overload("FindAll_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			// Need to figure this out
			name := "Flanksource"
			return types.DefaultTypeAdapter.NativeToValue([]string{name, name + "suffix"})

		}),
	),
)

var MatchregexpGen = cel.Function("Match",
	cel.Overload("Match_interface{}_interface{}",

		[]*cel.Type{
			cel.DynType, cel.DynType,
		},
		cel.BoolType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x ReFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.Match(args[0], args[1]))

		}),
	),
)

var QuoteMetaregexpGen = cel.Function("QuoteMeta",
	cel.Overload("QuoteMeta_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x ReFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.QuoteMeta(args[0]))

		}),
	),
)

var ReplaceregexpGen = cel.Function("Replace",
	cel.Overload("Replace_interface{}_interface{}_interface{}",

		[]*cel.Type{
			cel.DynType, cel.DynType, cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x ReFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.Replace(args[0], args[1], args[2]))

		}),
	),
)

var ReplaceLiteralregexpGen = cel.Function("ReplaceLiteral",
	cel.Overload("ReplaceLiteral_interface{}_interface{}_interface{}",

		[]*cel.Type{
			cel.DynType, cel.DynType, cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			// Need to figure this out
			name := "Flanksource"
			return types.DefaultTypeAdapter.NativeToValue([]string{name, name + "suffix"})

		}),
	),
)

var SplitregexpGen = cel.Function("Split",
	cel.Overload("Split_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			// Need to figure this out
			name := "Flanksource"
			return types.DefaultTypeAdapter.NativeToValue([]string{name, name + "suffix"})

		}),
	),
)
