// Code generated by gencel. DO NOT EDIT.

package funcs

import "github.com/google/cel-go/cel"
import "github.com/google/cel-go/common/types"
import "github.com/google/cel-go/common/types/ref"

var randomASCIIGen = cel.Function("random.ASCII",
	cel.Overload("random.ASCII_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x RandomFuncs

			result, err := x.ASCII(args[0])
			if err != nil {
				return types.WrapErr(err)
			}
			return types.DefaultTypeAdapter.NativeToValue(result)

		}),
	),
)

var randomAlphaGen = cel.Function("random.Alpha",
	cel.Overload("random.Alpha_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x RandomFuncs

			result, err := x.Alpha(args[0])
			if err != nil {
				return types.WrapErr(err)
			}
			return types.DefaultTypeAdapter.NativeToValue(result)

		}),
	),
)

var randomAlphaNumGen = cel.Function("random.AlphaNum",
	cel.Overload("random.AlphaNum_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x RandomFuncs

			result, err := x.AlphaNum(args[0])
			if err != nil {
				return types.WrapErr(err)
			}
			return types.DefaultTypeAdapter.NativeToValue(result)

		}),
	),
)

var randomStringGen = cel.Function("random.String",
	cel.Overload("random.String_interface{}_interface{}",
		[]*cel.Type{
			cel.DynType, cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {
			list, err := sliceToNative[interface{}](args[1].(ref.Val))
			if err != nil {
					return types.WrapErr(err)
			}
			
			var x RandomFuncs
			result, err := x.String(args[0], list...)
			if err != nil {
				return types.WrapErr(err)
			}
			return types.String(result)

		}),
	),
)

var randomItemGen = cel.Function("random.Item",
	cel.Overload("random.Item_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x RandomFuncs
			list, err := sliceToNative[interface{}](args[0].(ref.Val))
			if err != nil {
				return types.WrapErr(err)
			}

			result, err := x.Item(list)
			if err != nil {
				return types.WrapErr(err)
			}

			return types.DefaultTypeAdapter.NativeToValue(result)

		}),
	),
)

var randomNumberGen = cel.Function("random.Number",
	cel.Overload("random.Number_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x RandomFuncs
			list, err := sliceToNative[interface{}](args[0].(ref.Val))

			if err != nil {
				return types.WrapErr(err)
			}

			result, err := x.Number(list...)
			if err != nil {
				return types.WrapErr(err)
			}

			return types.DefaultTypeAdapter.NativeToValue(result)

		}),
	),
)

var randomFloatGen = cel.Function("random.Float",
	cel.Overload("random.Float_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x RandomFuncs
			list, err := sliceToNative[interface{}](args[0].(ref.Val))
			if err != nil {
				return types.WrapErr(err)
			}

			result, err := x.Float(list...)
			if err != nil {
				return types.WrapErr(err)
			}

			return types.DefaultTypeAdapter.NativeToValue(result)

		}),
	),
)
