// Code generated by "gencel";
// DO NOT EDIT.

package funcs

import "github.com/google/cel-go/common/types"
import "github.com/google/cel-go/cel"
import "github.com/google/cel-go/common/types/ref"

var WPAPSKcryptoGen = cel.Function("crypto.WPAPSK",
	cel.Overload("crypto.WPAPSK_interface{}_interface{}",

		[]*cel.Type{
			cel.DynType, cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs
			a0, a1 := x.WPAPSK(args[0], args[1])
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var SHA1cryptoGen = cel.Function("crypto.SHA1",
	cel.Overload("crypto.SHA1_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.SHA1(args[0]))

		}),
	),
)

var SHA224cryptoGen = cel.Function("crypto.SHA224",
	cel.Overload("crypto.SHA224_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.SHA224(args[0]))

		}),
	),
)

var SHA256cryptoGen = cel.Function("crypto.SHA256",
	cel.Overload("crypto.SHA256_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.SHA256(args[0]))

		}),
	),
)

var SHA384cryptoGen = cel.Function("crypto.SHA384",
	cel.Overload("crypto.SHA384_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.SHA384(args[0]))

		}),
	),
)

var SHA512cryptoGen = cel.Function("crypto.SHA512",
	cel.Overload("crypto.SHA512_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.SHA512(args[0]))

		}),
	),
)

var SHA512_224cryptoGen = cel.Function("crypto.SHA512_224",
	cel.Overload("crypto.SHA512_224_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.SHA512_224(args[0]))

		}),
	),
)

var SHA512_256cryptoGen = cel.Function("crypto.SHA512_256",
	cel.Overload("crypto.SHA512_256_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.SHA512_256(args[0]))

		}),
	),
)

var SHA1BytescryptoGen = cel.Function("crypto.SHA1Bytes",
	cel.Overload("crypto.SHA1Bytes_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs
			a0, a1 := x.SHA1Bytes(args[0])
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var SHA224BytescryptoGen = cel.Function("crypto.SHA224Bytes",
	cel.Overload("crypto.SHA224Bytes_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs
			a0, a1 := x.SHA224Bytes(args[0])
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var SHA256BytescryptoGen = cel.Function("crypto.SHA256Bytes",
	cel.Overload("crypto.SHA256Bytes_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs
			a0, a1 := x.SHA256Bytes(args[0])
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var SHA384BytescryptoGen = cel.Function("crypto.SHA384Bytes",
	cel.Overload("crypto.SHA384Bytes_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs
			a0, a1 := x.SHA384Bytes(args[0])
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var SHA512BytescryptoGen = cel.Function("crypto.SHA512Bytes",
	cel.Overload("crypto.SHA512Bytes_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs
			a0, a1 := x.SHA512Bytes(args[0])
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var SHA512_224BytescryptoGen = cel.Function("crypto.SHA512_224Bytes",
	cel.Overload("crypto.SHA512_224Bytes_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs
			a0, a1 := x.SHA512_224Bytes(args[0])
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var SHA512_256BytescryptoGen = cel.Function("crypto.SHA512_256Bytes",
	cel.Overload("crypto.SHA512_256Bytes_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs
			a0, a1 := x.SHA512_256Bytes(args[0])
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var RSAEncryptcryptoGen = cel.Function("crypto.RSAEncrypt",
	cel.Overload("crypto.RSAEncrypt_string_interface{}",

		[]*cel.Type{
			cel.StringType, cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs
			a0, a1 := x.RSAEncrypt(args[0].Value().(string), args[1])
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var RSADecryptcryptoGen = cel.Function("crypto.RSADecrypt",
	cel.Overload("crypto.RSADecrypt_string_[]byte",

		[]*cel.Type{
			cel.StringType, cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs
			a0, a1 := x.RSADecrypt(args[0].Value().(string), args[1].Value().([]byte))
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var RSADecryptBytescryptoGen = cel.Function("crypto.RSADecryptBytes",
	cel.Overload("crypto.RSADecryptBytes_string_[]byte",

		[]*cel.Type{
			cel.StringType, cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs
			a0, a1 := x.RSADecryptBytes(args[0].Value().(string), args[1].Value().([]byte))
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var RSADerivePublicKeycryptoGen = cel.Function("crypto.RSADerivePublicKey",
	cel.Overload("crypto.RSADerivePublicKey_string",

		[]*cel.Type{
			cel.StringType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs
			a0, a1 := x.RSADerivePublicKey(args[0].Value().(string))
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var ECDSADerivePublicKeycryptoGen = cel.Function("crypto.ECDSADerivePublicKey",
	cel.Overload("crypto.ECDSADerivePublicKey_string",

		[]*cel.Type{
			cel.StringType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs
			a0, a1 := x.ECDSADerivePublicKey(args[0].Value().(string))
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)
