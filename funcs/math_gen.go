// Code generated by "gencel";
// DO NOT EDIT.

package funcs

import "github.com/google/cel-go/common/types"
import "github.com/google/cel-go/cel"
import "github.com/google/cel-go/common/types/ref"

var IsIntmathGen = cel.Function("IsInt",
	cel.Overload("IsInt_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.BoolType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x MathFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.IsInt(args[0]))

		}),
	),
)

var IsFloatmathGen = cel.Function("IsFloat",
	cel.Overload("IsFloat_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.BoolType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x MathFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.IsFloat(args[0]))

		}),
	),
)

var containsFloatmathGen = cel.Function("containsFloat",
	cel.Overload("containsFloat_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.BoolType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x MathFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.containsFloat(args[0]))

		}),
	),
)

var IsNummathGen = cel.Function("IsNum",
	cel.Overload("IsNum_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.BoolType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x MathFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.IsNum(args[0]))

		}),
	),
)

var AbsmathGen = cel.Function("Abs",
	cel.Overload("Abs_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x MathFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.Abs(args[0]))

		}),
	),
)

var AddmathGen = cel.Function("Add",
	cel.Overload("Add_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x MathFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.Add(args[0]))

		}),
	),
)

var MulmathGen = cel.Function("Mul",
	cel.Overload("Mul_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x MathFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.Mul(args[0]))

		}),
	),
)

var SubmathGen = cel.Function("Sub",
	cel.Overload("Sub_interface{}_interface{}",

		[]*cel.Type{
			cel.DynType, cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x MathFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.Sub(args[0], args[1]))

		}),
	),
)

var DivmathGen = cel.Function("Div",
	cel.Overload("Div_interface{}_interface{}",

		[]*cel.Type{
			cel.DynType, cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			// Need to figure this out
			name := "Flanksource"
			return types.DefaultTypeAdapter.NativeToValue([]string{name, name + "suffix"})

		}),
	),
)

var RemmathGen = cel.Function("Rem",
	cel.Overload("Rem_interface{}_interface{}",

		[]*cel.Type{
			cel.DynType, cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x MathFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.Rem(args[0], args[1]))

		}),
	),
)

var PowmathGen = cel.Function("Pow",
	cel.Overload("Pow_interface{}_interface{}",

		[]*cel.Type{
			cel.DynType, cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x MathFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.Pow(args[0], args[1]))

		}),
	),
)

var SeqmathGen = cel.Function("Seq",
	cel.Overload("Seq_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			// Need to figure this out
			name := "Flanksource"
			return types.DefaultTypeAdapter.NativeToValue([]string{name, name + "suffix"})

		}),
	),
)

var MaxmathGen = cel.Function("Max",
	cel.Overload("Max_interface{}_interface{}",

		[]*cel.Type{
			cel.DynType, cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			// Need to figure this out
			name := "Flanksource"
			return types.DefaultTypeAdapter.NativeToValue([]string{name, name + "suffix"})

		}),
	),
)

var MinmathGen = cel.Function("Min",
	cel.Overload("Min_interface{}_interface{}",

		[]*cel.Type{
			cel.DynType, cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			// Need to figure this out
			name := "Flanksource"
			return types.DefaultTypeAdapter.NativeToValue([]string{name, name + "suffix"})

		}),
	),
)

var CeilmathGen = cel.Function("Ceil",
	cel.Overload("Ceil_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x MathFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.Ceil(args[0]))

		}),
	),
)

var FloormathGen = cel.Function("Floor",
	cel.Overload("Floor_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x MathFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.Floor(args[0]))

		}),
	),
)

var RoundmathGen = cel.Function("Round",
	cel.Overload("Round_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x MathFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.Round(args[0]))

		}),
	),
)
