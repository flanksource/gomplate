// Code generated by gencel. DO NOT EDIT.

package funcs

import "github.com/google/cel-go/cel"
import "github.com/google/cel-go/common/types"
import "github.com/google/cel-go/common/types/ref"

var dataJSONGen = cel.Function("JSON",
	cel.Overload("JSON_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x DataFuncs

			result, err := x.JSON(args[0])
			if err != nil {
				return types.NewErr(err.Error())
			}
			return types.DefaultTypeAdapter.NativeToValue(result)

		}),
	),
)

var dataJSONArrayGen = cel.Function("JSONArray",
	cel.Overload("JSONArray_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x DataFuncs

			result, err := x.JSONArray(args[0])
			if err != nil {
				return types.NewErr(err.Error())
			}
			return types.DefaultTypeAdapter.NativeToValue(result)

		}),
	),
)

var dataYAMLGen = cel.Function("YAML",
	cel.Overload("YAML_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x DataFuncs

			result, err := x.YAML(args[0])
			if err != nil {
				return types.NewErr(err.Error())
			}
			return types.DefaultTypeAdapter.NativeToValue(result)

		}),
	),
)

var dataYAMLArrayGen = cel.Function("YAMLArray",
	cel.Overload("data.YAMLArray_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x DataFuncs

			result, err := x.YAMLArray(args[0].Value())
			if err != nil {
				return types.NewErr(err.Error())
			}
			return types.DefaultTypeAdapter.NativeToValue(result)

		}),
	),
)

var dataTOMLGen = cel.Function("TOML",
	cel.Overload("TOML_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x DataFuncs

			result, err := x.TOML(args[0])
			if err != nil {
				return types.NewErr(err.Error())
			}
			return types.DefaultTypeAdapter.NativeToValue(result)


		}),
	),
)

var dataCSVGen = cel.Function("CSV",
	cel.Overload("CSV_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x DataFuncs
			list := transferSlice[string](args[0].(ref.Val))

			result, err := x.CSV(list...)
			if err != nil {
				return types.NewErr(err.Error())
			}
			return types.DefaultTypeAdapter.NativeToValue(result)

		}),
	),
)

var dataCSVByRowGen = cel.Function("data.CSVByRow",
	cel.Overload("data.CSVByRow_string",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x DataFuncs
			list := transferSlice[string](args[0].(ref.Val))

			result, err := x.CSVByRow(list...)
			if err != nil {
				return types.NewErr(err.Error())
			}
			return types.DefaultTypeAdapter.NativeToValue(result)

		}),
	),
)

var dataCSVByColumnGen = cel.Function("data.CSVByColumn",
	cel.Overload("data.CSVByColumn_string",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x DataFuncs
			list := transferSlice[string](args[0].(ref.Val))

			result, err := x.CSVByColumn(list...)
			if err != nil {
				return types.NewErr(err.Error())
			}
			return types.DefaultTypeAdapter.NativeToValue(result)
		}),
	),
)

var dataToCSVGen = cel.Function("toCSV",
	cel.Overload("toCSV_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x DataFuncs
			list := transferSlice[interface{}](args[0].(ref.Val))

			result, err := x.ToCSV(list...)
			if err != nil {
				return types.NewErr(err.Error())
			}
			return types.String(result)

		}),
	),
)

var dataToJSONGen = cel.Function("toJSON",
	cel.Overload("toJSON_string",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x DataFuncs

			result, err := x.ToJSON(args[0].Value())
			if err != nil {
				return types.NewErr(err.Error())
			}
			return types.String(result)

		}),
	),
)

var dataToJSONPrettyGen = cel.Function("toJSONPretty",
	cel.Overload("toJSONPretty_interface{}",

		[]*cel.Type{
			 cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x DataFuncs

			result, err := x.ToJSONPretty("  ", args[0].Value())
			if err != nil {
				return types.NewErr(err.Error())
			}
			return types.String(result)

		}),
	),
)

var dataToYAMLGen = cel.Function("toYAML",
	cel.Overload("toYAML_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x DataFuncs

			result, err := x.ToYAML(args[0].Value())
			if err != nil {
				return types.NewErr(err.Error())
			}
			return types.String(result)
		}),
	),
)

var dataToTOMLGen = cel.Function("toTOML",
	cel.Overload("toTOML_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x DataFuncs

			result, err := x.ToTOML(args[0].Value())
			if err != nil {
				return types.NewErr(err.Error())
			}
			return types.String(result)

		}),
	),
)
